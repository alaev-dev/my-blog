# Dependency Injection (DI)

Когда вы разрабатываете небольшую часть системы, например, модуль или класс, вам может понадобиться использовать функции других классов. Например, вам может понадобиться HTTP-сервис для выполнения обращений к бэкенду. Инъекция зависимости (Dependency Injection, или DI) — это шаблон проектирования и механизм создания и передачи одних частей приложения другим частям приложения, которым они необходимы. Angular поддерживает этот шаблон проектирования, и вы можете использовать его в своих приложениях для повышения гибкости и модульности.

В Angular зависимости обычно представляют собой сервисы, но они также могут быть значениями, например, строками или функциями. Инжектор для приложения (создаваемый автоматически во время bootstrap) инстанцирует зависимости, когда это необходимо, используя настроенный поставщик сервиса или значения.

## Понимание инъекции зависимостей

Инъекция зависимостей, или `DI`, является одной из фундаментальных концепций в Angular. `DI` встроен в фреймворк Angular и позволяет классам с декораторами Angular, такими как `Components`, `Directives`, `Pipes` и `Injectables`, настраивать необходимые им зависимости.

В системе `DI` существуют две основные роли: потребитель зависимостей и поставщик зависимостей.

Angular облегчает взаимодействие между потребителями зависимостей и поставщиками зависимостей, используя абстракцию под названием `Injector`. Когда запрашивается зависимость, инжектор проверяет свой реестр на предмет наличия уже доступного экземпляра. Если нет, создается новый экземпляр и сохраняется в реестре. Angular создает инжектор для всего приложения (также известный как "корневой" инжектор) во время процесса загрузки приложения, а также другие инжекторы по мере необходимости. В большинстве случаев вам не нужно вручную создавать инжекторы, но вы должны знать, что существует слой, соединяющий провайдеров и потребителей.

В этом уроке рассмотрим основные сценарии того, как классы и другие сущности (функции, объекты, примитивные типы) могут выступать в качестве зависимости.

### Предоставление зависимостей

Процесс предоставления сервисов в качестве зависимостей описан в [предыдущем уроке](5-services.md#опеределение-сервисов-в-приложении)

### Инжектирование зависимости

Самый распространенный способ внедрения зависимости — объявить ее в конструкторе класса. Когда Angular создает новый экземпляр компонента, директивы или класса `pipe`, он определяет, какие сервисы или другие зависимости нужны этому классу, глядя на типы параметров конструктора. Например, если `HeroListComponent` нуждается в `HeroService`, конструктор может выглядеть следующим образом:

```ts
@Component({
  /* ... */
})
class HeroListComponent {
  constructor(private readonly service: HeroService) {}
}
```

Когда Angular обнаруживает, что компонент зависит от сервиса, он сначала проверяет, есть ли в инжекторе существующие экземпляры этого сервиса. Если запрошенный экземпляр сервиса еще не существует, инжектор создает его, используя зарегистрированного провайдера, и добавляет его в инжектор перед тем, как вернуть сервис в Angular.

Когда все запрошенные сервисы будут разрешены и возвращены, Angular может вызвать конструктор компонента с этими сервисами в качестве аргументов.

![Процесс инъекции](/public/6_1-inject-service.png)

## Настройка поставщиков зависимостей

В теме Создание и внедрение сервисов описывается использование классов в качестве зависимостей. Помимо классов, в качестве зависимостей можно использовать и другие значения, такие как булевы, строки, даты и объекты. Angular `DI` предоставляет необходимые `API` для гибкой настройки зависимостей, поэтому вы можете сделать эти значения доступными в `DI`.

### Указание провайдера

Если вы укажете класс сервиса в качестве поставщика, инжектор по умолчанию будет создавать этот класс с помощью оператора new.

В следующем примере класс `Logger` предоставляет экземпляр `Logger`.

```ts
providers: [Logger];
```

Однако вы можете настроить `DI` на использование другого класса или любого другого значения для ассоциации с классом `Logger`. Таким образом, когда `Logger` будет инжектирован, вместо него будет использоваться это новое значение.

Фактически, синтаксис провайдера класса — это сокращенное выражение, которое расширяется в конфигурацию провайдера, определяемую интерфейсом `Provider`.

Angular расширяет значение `providers` в данном случае в полный объект провайдера следующим образом:

```ts
[{ provide: Logger, useClass: Logger }];
```

Расширенная конфигурация провайдера представляет собой объект с двумя свойствами:

- Свойство `provide` содержит токен, который служит ключом для поиска значения зависимости и настройки инжектора.
- Второе свойство — это объект определения провайдера, который указывает инжектору, как создать значение зависимости. Ключ определения провайдера может быть одним из следующих:
  - `useClass` — этот параметр указывает Angular DI создавать предоставленный класс при инжектировании зависимости
  - `useExisting` — позволяет использовать псевдоним и ссылаться на другой существущий класс.
  - `useFactory` — позволяет определить функцию, которая создает зависимость.
  - `useValue` — предоставляет статическое значение, которое должно быть использовано в качестве зависимости.

В следующем разделе описано, как использовать упомянутые ключи определения провайдера.

### Провайдеры классов: `useClass`

Ключ провайдера `useClass` позволяет вам создавать и возвращать новый экземпляр указанного класса. Вы можете использовать этот тип провайдера для замены альтернативной реализации общего класса или класса по умолчанию. Альтернативная реализация может, например, реализовать другую стратегию, расширить класс по умолчанию или эмулировать поведение реального класса в тестовом примере.

В следующем примере класс `BetterLogger` будет создан, когда зависимость `Logger` будет запрошена в компоненте или любом другом классе.

```ts
[{ provide: Logger, useClass: BetterLogger }];
```

Если альтернативные провайдеры классов имеют свои собственные зависимости, укажите обоих провайдеров в свойстве метаданных провайдеров родительского модуля или компонента.

```ts
[UserService, { provide: Logger, useClass: EvenBetterLogger }];
```

В этом примере `EvenBetterLogger` отображает имя пользователя в сообщении журнала. Этот логгер получает пользователя из инжектированного экземпляра `UserService`.

```ts
@Injectable()
export class EvenBetterLogger extends Logger {
  constructor(private userService: UserService) {
    super();
  }

  override log(message: string) {
    const name = this.userService.user.name;
    super.log(`Message to ${name}: ${message}`);
  }
}
```

Angular `DI` знает, как построить зависимость `UserService`, поскольку она была настроена выше и доступна в инжекторе.

### Псевдоним провайдера: `useExisting`

Ключ провайдера useExisting позволяет сопоставить один токен с другим. По сути, первый токен является псевдонимом для сервиса, связанного со вторым токеном, создавая два способа доступа к одному и тому же объекту сервиса.

В следующем примере инжектор внедряет экземпляр `NewLogger`, когда компонент запрашивает либо новый, либо старый логгер. Таким образом, `OldLogger` является псевдонимом для `NewLogger`.

```ts
[
  NewLogger,
  // Псевдони для OldLogger - NewLogger
  { provide: OldLogger, useExisting: NewLogger },
];
```

Убедитесь, что вы не переименовываете `OldLogger` в `NewLogger` с помощью `useClass`, так как это создаст два разных экземпляра `NewLogger`.

### Провайдеры фабрик: `useFactory`

Ключ провайдера `useFactory` позволяет вам создать зависимый объект путем вызова фабричной функции. При таком подходе вы можете создать динамическое значение на основе информации, доступной в `DI` и в других местах приложения.

В следующем примере только авторизованные пользователи должны видеть секретных героев в `HeroService`. Авторизация может меняться в течение одного сеанса работы приложения, например, когда другой пользователь входит в систему.

Чтобы сохранить чувствительную к безопасности информацию в `UserService` и вне `HeroService`, задайте конструктору `HeroService` булев флаг для управления отображением секретных героев.

```ts
@Injectable()
class HeroService {
  constructor(private readonly logger: Logger, private readonly isAuthorized: boolean) {}

  getHeroes() {
    const auth = this.isAuthorized ? "authorized " : "unauthorized";
    this.logger.log(`Getting heroes for ${auth} user.`);
    return HEROES.filter((hero) => this.isAuthorized || !hero.isSecret);
  }
}
```

Чтобы реализовать флаг `isAuthorized`, используйте фабрику-провайдер для создания нового экземпляра логгера для `HeroService`.

```ts
const heroServiceFactory = (logger: Logger, userService: UserService) => new HeroService(logger, userService.user.isAuthorized);
```

Функция `factory` имеет доступ к `UserService`. Вы инжектируете `Logger` и `UserService` в провайдер фабрики, чтобы инжектор мог передать их функции фабрики.

```ts
export const heroServiceProvider: FactoryProvider = {
  provide: HeroService,
  useFactory: heroServiceFactory,
  deps: [Logger, UserService],
};
```

- Поле `useFactory` указывает, что провайдер является фабричной функцией, реализация которой — `heroServiceFactory`.
- Свойство `deps` представляет собой массив маркеров провайдера.

Классы `Logger` и `UserService` служат маркерами для своих собственных классов-провайдеров. Инжектор разрешает эти маркеры и вводит соответствующие сервисы в соответствующие параметры фабричной функции `heroServiceFactory`.

Захват провайдера фабрики в экспортируемой переменной `heroServiceProvider` делает провайдер фабрики многократно используемым.

### Провайдеры значений: `useValue`

Ключ `useValue` позволяет связать фиксированное значение с маркером `DI`. Используйте эту технику для предоставления констант конфигурации во время выполнения, таких как базовые адреса веб-сайтов и флаги функций. Вы также можете использовать провайдер значения в модульном тестировании для предоставления имитационных данных вместо производственной службы данных. В следующем разделе представлена дополнительная информация о ключе `useValue`.

### Использование объекта InjectionToken

Определите и используйте объект `InjectionToken` для выбора маркера провайдера для неклассовых зависимостей. В следующем примере определен токен `APP_CONFIG` типа `InjectionToken`.

```ts
import { InjectionToken } from "@angular/core";

export const APP_CONFIG = new InjectionToken<AppConfig>("app.config");
```

Необязательный параметр `type`, `<AppConfig>`, и описание токена, `app.config`, определяют назначение токена.

Далее зарегистрируйте провайдер зависимостей в компоненте, используя объект `InjectionToken` из `APP_CONFIG`.

```ts
providers: [{ provide: APP_CONFIG, useValue: HERO_DI_CONFIG }];
```

Теперь внедрите объект конфигурации в конструктор с помощью декоратора параметров `@Inject()`.

```ts
constructor(@Inject(APP_CONFIG) config: AppConfig) {
  this.title = config.title;
}
```

### Интерфейсы и DI

Хотя интерфейс TypeScript AppConfig поддерживает типизацию внутри класса, интерфейс AppConfig не играет никакой роли в DI. В TypeScript интерфейс является артефактом времени проектирования и не имеет представления во время выполнения, или маркера, который может использовать система DI.

Когда транспилятор меняет TypeScript на JavaScript, интерфейс исчезает, потому что в JavaScript нет интерфейсов.

Поскольку у Angular нет интерфейса, который он мог бы найти во время выполнения, интерфейс не может быть маркером, и вы не можете его внедрить.

```ts
// Мы не можем использовать интерфейс AppConfig как токен для предоставления зависимостей
[{ provide: AppConfig, useValue: HERO_DI_CONFIG })]
```

```ts
// Мы не можем инжектировать зависимость по интерфейсу
constructor(private config: AppConfig){ }
```

## Иерархические инжекторы

Приложения, которые вы создаете с помощью Angular, могут стать довольно большими, и одним из способов управления этой сложностью является разделение приложения на множество небольших хорошо инкапсулированных модулей, которые сами по себе разделены на четко определенное дерево компонентов.

На вашей странице могут быть разделы, которые работают совершенно независимо от остальной части приложения, со своими локальными копиями служб и других зависимостей, которые им необходимы. Некоторые из сервисов, которые используют эти разделы приложения, могут быть общими с другими частями приложения или с родительскими компонентами, которые находятся дальше по дереву компонентов, в то время как другие зависимости должны быть частными.

С помощью иерархической инъекции зависимостей вы можете изолировать разделы приложения и предоставить им свои собственные частные зависимости, не разделяемые с остальной частью приложения, или заставить родительские компоненты разделять определенные зависимости только с дочерними компонентами, но не с остальной частью дерева компонентов, и так далее. Иерархическая инъекция зависимостей позволяет вам обмениваться зависимостями между различными частями приложения только тогда, когда и если это необходимо.

### Типы иерархий инжекторов

Инжекторы в Angular имеют правила, которые вы можете использовать для достижения желаемой видимости инжекторов в ваших приложениях. Понимая эти правила, вы можете определить, в каком `NgModule`, `Component` или `Directive` вам следует объявить провайдер.

| Иерархии инжекторов        | Подробности                                                                                                                                                         |
| -------------------------- | ------------------------------------------------------------------------------------------------------------------------------------------------------------------- |
| Иерархия `ModuleInjector`  | Настройте `ModuleInjector` в этой иерархии, используя аннотацию `@NgModule()` или `@Injectable()`.                                                                  |
| Иерархия `ElementInjector` | Создается неявно в каждом элементе `DOM`. По умолчанию `ElementInjector` пуст, если вы не настроили его в свойстве `providers` в `@Directive()` или `@Component()`. |

### ModuleInjector

Инжектор модулей можно настроить одним из двух способов, используя:

Свойство `@Injectable() providedIn` для ссылки на `@NgModule()`, или `root`.
Массив `@NgModule() providers`. И

#### \*Tree-shaking и @Injectable()

Использование свойства `@Injectable() providedIn` предпочтительнее, чем использование массива `@NgModule() providers`. Используя `@Injectable() providedIn`, инструменты оптимизации могут выполнять древовидную встряску, которая удаляет сервисы, не используемые вашим приложением. Это приводит к уменьшению размера пакета.

### Инжектор платформы

Есть еще два инжектора над `root`, дополнительный `ModuleInjector` и `NullInjector()`.

Рассмотрим, как Angular загружает приложение, используя следующее в файле `main.ts`:

```ts
platformBrowserDynamic().bootstrapModule(AppModule).then(ref => {…})
```

Метод `bootstrapModule()` создает дочерний инжектор инжектора платформы, который конфигурируется `AppModule`. Это корневой `ModuleInjector`.

Метод `platformBrowserDynamic()` создает инжектор, настроенный `PlatformModule`, который содержит специфические для платформы зависимости. Это позволяет нескольким приложениям совместно использовать конфигурацию платформы.

Например, браузер имеет только одну строку URL, независимо от того, сколько приложений у вас запущено.

Следующая диаграмма представляет отношения между корневым `ModuleInjector` и его родительскими инжекторами.

![Инжекторы](/public/6_2-injectors.jpg)

### ElementInjector

Angular создает иерархии ElementInjector неявно для каждого элемента DOM.

Предоставление сервиса в декораторе `@Component()` с помощью свойства `providers` или `viewProviders` настраивает `ElementInjector`.

Когда вы предоставляете услуги в компоненте, эта услуга доступна через `ElementInjector` в данном экземпляре компонента. Он также может быть виден в дочерних компонентах/директивах на основании правил видимости, описанных в разделе Правила разрешения.

Когда экземпляр компонента уничтожается, уничтожается и экземпляр сервиса.

### Правила поиска зависимостей

При разрешении токена для компонента/директивы, Angular разрешает его в два этапа:

По отношению к родителям в иерархии `ElementInjector`.
По отношению к родителям в иерархии `ModuleInjector`.
Когда компонент объявляет зависимость, Angular пытается удовлетворить эту зависимость с помощью собственного `ElementInjector`. Если инжектору компонента не хватает провайдера, он передает запрос вверх к `ElementInjector` своего родительского компонента.

Запросы продолжают передаваться до тех пор, пока Angular не найдет инжектор, способный обработать запрос, или пока не закончатся иерархии предков `ElementInjector`.

Если Angular не находит провайдера ни в одной иерархии `ElementInjector`, он возвращается к элементу, откуда пришел запрос, и ищет его в иерархии `ModuleInjector`. Если Angular все еще не находит провайдера, он выдает ошибку.

Если вы зарегистрировали провайдера для одного и того же `DI`-токена на разных уровнях, то для разрешения зависимости Angular использует первый встреченный провайдер. Если, например, провайдер зарегистрирован локально в компоненте, которому нужен сервис,

Angular не будет искать другого провайдера той же услуги.

### Модификаторы поиска зависимостей

Поведение Angular при разрешении может быть изменено с помощью `@Optional()`, `@Self()`, `@SkipSelf()` и `@Host()`. Импортируйте каждый из них из @angular/core и используйте каждый в конструкторе класса компонента, когда вы внедряете свой сервис.

Рабочее приложение, демонстрирующее модификаторы разрешения, которые рассматриваются в этом разделе, смотрите в примере [модификаторов разрешения](https://angular.io/generated/live-examples/resolution-modifiers/stackblitz.html).

#### Типы модификаторов

Модификаторы разрешения делятся на три категории:

- Что делать, если Angular не находит то, что вы ищете, то есть `@Optional()`.
- Где начать поиск, то есть `@SkipSelf()`.
- Где остановить поиск, `@Host()` и `@Self()`.

По умолчанию Angular всегда начинает с текущего `Injector` и продолжает поиск по всему пути вверх. Модификаторы позволяют изменять начальное, или `self`, местоположение и конечное местоположение.

Кроме того, вы можете комбинировать все модификаторы, кроме `@Host()` и `@Self()` и, конечно, `@SkipSelf()` и `@Self()`.

#### @Optional()

`@Optional()` позволяет Angular считать сервис, который вы вводите, необязательным. Таким образом, если он не может быть разрешен во время выполнения, Angular разрешает его как `null`, а не выдает ошибку.

В следующем примере сервис `OptionalService` не предоставляется ни в сервисе, ни в `@NgModule()`, ни в классе компонента, поэтому он недоступен нигде в приложении.

```ts
export class OptionalComponent {
  constructor(@Optional() optional: OptionalService | null) {}
}
```

## Домашнее задание

Дан интерфейс логгера.

```ts
interface Logger {
  log(message: string): void;
  warn(message: string): void;
  error(message: string): void;
}
```

Вам необходимо разработать три реализации логгеров, которые должны реализовывать данный интерфейс:

- `ConsoleLoggerService` для вывода сообщений в консоль.
- `FileLoggerService` для имитации записи сообщений в файл (в данном случае вывод в консоль с префиксом "File").
- `EventLoggerService` для имитации отправки логов в систему событий (в данном случае вывод в консоль с префиксом "Event").

Далее доработайте данный компонент так, чтобы он мог использовать любую реализацию логгера без изменения кода самого компонента. (Подсказка - используйте injection token-ы). При нажатии на кнопки - должны вызываться соответствующие методы логгера.

Предоставлять необходимый логгер можете в секции providers в компоненте.

> Дополнительный вопрос. Можно ли в данном случае обойтись без injection tokens?

```ts
import { Component } from "@angular/core";

@Component({
  selector: "app-log-buttons",
  template: `
    <button>Log Message</button>
    <button>Warn Message</button>
    <button>Error Message</button>
  `,
  changeDetection: ChangeDetectionStrategy.OnPush,
})
export class LogButtonsComponent {}
```

### Для учителей

```ts
const LOGGER = new InjectionToken<Logger>('Logger');


@Injectable()
class ConsoleLoggerService implements Logger {
  ...
}

@Injectable()
class FileLoggerService implements Logger {
  ...
}

@Injectable()
class EventLoggerService implements Logger {
  ...
}

@Component({
  selector: "app-log-buttons",
  template: `
    <button (click)="log()">Log Message</button>
    <button (click)="warn()">Warn Message</button>
    <button (click)="error()">Error Message</button>
  `,
  changeDetection: ChangeDetectionStrategy.OnPush,
  providers: [
    {
      provide: LOGGER,
      useClass: FileLoggerService,
    }
  ],
})
export class LogButtonsComponent {
  constructor(@Inject(LOGGER) private readonly logger: Logger) {}
}
```
